{"version":3,"sources":["../src/index.ts","../../internal-constants/src/index.ts"],"sourcesContent":["import {\n  DESTINATION_HEADER_NAME,\n  PROJECT_KEY_HEADER_NAME,\n  PROTOCOL_HEADER_NAME,\n  PAYLOAD_HEADER_NAME,\n} from \"internal-constants\";\n\nexport type FetchFunction = typeof fetch;\n\nexport type FetchProxyOptions = {\n  projectKey: string;\n  url?: string;\n  env?: string;\n};\n\ntype InputType = Parameters<FetchFunction>[0];\ntype InitType = Parameters<FetchFunction>[1];\n\nconst DEFAULT_OPTIONS = {\n  url: \"https://proxy.apihero.run\",\n  env: \"development\",\n};\n\nexport function createFetchProxy(options: FetchProxyOptions): FetchFunction {\n  const { projectKey, url: proxyUrl, env } = { ...DEFAULT_OPTIONS, ...options };\n\n  return async function fetchProxy(\n    input: InputType,\n    init?: InitType\n  ): Promise<Response> {\n    const extractedUrl =\n      typeof input === \"string\"\n        ? input\n        : input instanceof Request\n        ? input.url\n        : input.href;\n\n    const url = new URL(extractedUrl);\n\n    // Create a new URL object with the proxy URL as the base URL (and don't forget the search params)\n    const newUrl = new URL(url.pathname + url.search, proxyUrl);\n\n    // Get the headers from the original request, either in input === Request or from the init object\n    const headers = getOriginalHeaders(input, init);\n\n    // Add the headers that the proxy needs\n    headers.set(DESTINATION_HEADER_NAME, url.host);\n    headers.set(PROTOCOL_HEADER_NAME, url.protocol);\n    headers.set(PROJECT_KEY_HEADER_NAME, projectKey);\n    headers.set(PAYLOAD_HEADER_NAME, JSON.stringify({ env }));\n\n    // Create a new Request object with the new URL and the headers (and body if it's not a GET/HEAD/DELETE/OPTIONS request)\n    const newRequest = new Request(newUrl, {\n      ...init,\n      headers,\n      body: [\"GET\", \"HEAD\", \"DELETE\", \"OPTIONS\"].includes(\n        init?.method?.toUpperCase() ?? \"\"\n      )\n        ? undefined\n        : getOriginalBody(input, init),\n    });\n\n    // Call the original fetch function with the new Request object\n    return fetch(newRequest);\n  };\n}\n\nfunction getOriginalHeaders(input: InputType, init?: InitType): Headers {\n  if (input instanceof Request) {\n    return input.headers;\n  }\n\n  if (init?.headers) {\n    return new Headers(init.headers);\n  }\n\n  return new Headers();\n}\n\nfunction getOriginalBody(\n  input: InputType,\n  init?: InitType\n): BodyInit | null | undefined {\n  if (input instanceof Request) {\n    return input.body;\n  }\n\n  return init?.body;\n}\n","export const DESTINATION_HEADER_NAME = \"x-ah-origin\";\nexport const PROJECT_KEY_HEADER_NAME = \"x-ah-pk\";\nexport const REQUEST_ID_HEADER_NAME = \"x-ah-request-id\";\nexport const PROTOCOL_HEADER_NAME = \"x-ah-proto\";\nexport const PAYLOAD_HEADER_NAME = \"x-ah-payload\";\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAO,IAAM,0BAA0B;AAChC,IAAM,0BAA0B;AAEhC,IAAM,uBAAuB;AAC7B,IAAM,sBAAsB;;;ADcnC,IAAM,kBAAkB;AAAA,EACtB,KAAK;AAAA,EACL,KAAK;AACP;AAEO,SAAS,iBAAiB,SAA2C;AAC1E,QAAM,EAAE,YAAY,KAAK,UAAU,IAAI,IAAI,EAAE,GAAG,iBAAiB,GAAG,QAAQ;AAE5E,SAAO,eAAe,WACpB,OACA,MACmB;AA7BvB;AA8BI,UAAM,eACJ,OAAO,UAAU,WACb,QACA,iBAAiB,UACjB,MAAM,MACN,MAAM;AAEZ,UAAM,MAAM,IAAI,IAAI,YAAY;AAGhC,UAAM,SAAS,IAAI,IAAI,IAAI,WAAW,IAAI,QAAQ,QAAQ;AAG1D,UAAM,UAAU,mBAAmB,OAAO,IAAI;AAG9C,YAAQ,IAAI,yBAAyB,IAAI,IAAI;AAC7C,YAAQ,IAAI,sBAAsB,IAAI,QAAQ;AAC9C,YAAQ,IAAI,yBAAyB,UAAU;AAC/C,YAAQ,IAAI,qBAAqB,KAAK,UAAU,EAAE,IAAI,CAAC,CAAC;AAGxD,UAAM,aAAa,IAAI,QAAQ,QAAQ;AAAA,MACrC,GAAG;AAAA,MACH;AAAA,MACA,MAAM,CAAC,OAAO,QAAQ,UAAU,SAAS,EAAE;AAAA,UACzC,kCAAM,WAAN,mBAAc,kBAAiB;AAAA,MACjC,IACI,SACA,gBAAgB,OAAO,IAAI;AAAA,IACjC,CAAC;AAGD,WAAO,MAAM,UAAU;AAAA,EACzB;AACF;AAEA,SAAS,mBAAmB,OAAkB,MAA0B;AACtE,MAAI,iBAAiB,SAAS;AAC5B,WAAO,MAAM;AAAA,EACf;AAEA,MAAI,6BAAM,SAAS;AACjB,WAAO,IAAI,QAAQ,KAAK,OAAO;AAAA,EACjC;AAEA,SAAO,IAAI,QAAQ;AACrB;AAEA,SAAS,gBACP,OACA,MAC6B;AAC7B,MAAI,iBAAiB,SAAS;AAC5B,WAAO,MAAM;AAAA,EACf;AAEA,SAAO,6BAAM;AACf;","names":[]}