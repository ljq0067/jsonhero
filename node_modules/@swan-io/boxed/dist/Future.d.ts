import { Result } from "./Result";
declare type PendingPayload<Value> = {
    resolveCallbacks?: Array<(value: Value) => void>;
    cancelCallbacks?: Array<() => void>;
    cancel?: void | (() => void);
};
export declare type Future<Value> = FutureClass<Value> & ({
    tag: "Pending";
    pending: PendingPayload<Value>;
} | {
    tag: "Cancelled";
} | {
    tag: "Resolved";
    value: Value;
});
declare class FutureClass<Value> {
    tag: "Pending" | "Cancelled" | "Resolved";
    value?: Value;
    pending?: PendingPayload<Value>;
    constructor(_init: (resolver: (value: Value) => void) => (() => void) | void);
    isPending(): this is FutureClass<Value> & {
        tag: "Pending";
        value: PendingPayload<Value>;
    };
    isCancelled(): this is FutureClass<Value> & {
        tag: "Cancelled";
        value: undefined;
    };
    isResolved(): this is FutureClass<Value> & {
        tag: "Resolved";
        value: Value;
    };
    get(func: (value: Value) => void): void;
    onCancel(func: () => void): void;
    cancel(): void;
    map<ReturnValue>(func: (value: Value) => ReturnValue, propagateCancel?: boolean): Future<ReturnValue>;
    then(func: (value: Value) => void): this;
    flatMap<ReturnValue>(func: (value: Value) => Future<ReturnValue>, propagateCancel?: boolean): Future<ReturnValue>;
    tap(func: (value: Value) => unknown): Future<Value>;
    tapOk<Ok, Error>(this: FutureClass<Result<Ok, Error>>, func: (value: Ok) => unknown): Future<Result<Ok, Error>>;
    tapError<Ok, Error>(this: FutureClass<Result<Ok, Error>>, func: (value: Error) => unknown): Future<Result<Ok, Error>>;
    mapResult<Ok, Error, ReturnValue>(this: FutureClass<Result<Ok, Error>>, func: (value: Ok) => Result<ReturnValue, Error>, propagateCancel?: boolean): Future<Result<ReturnValue, Error>>;
    mapOk<Ok, Error, ReturnValue>(this: FutureClass<Result<Ok, Error>>, func: (value: Ok) => ReturnValue, propagateCancel?: boolean): Future<Result<ReturnValue, Error>>;
    mapError<Ok, Error, ReturnValue>(this: FutureClass<Result<Ok, Error>>, func: (value: Error) => ReturnValue, propagateCancel?: boolean): Future<Result<Ok, ReturnValue>>;
    flatMapOk<Ok, Error, ReturnValue>(this: FutureClass<Result<Ok, Error>>, func: (value: Ok) => Future<Result<ReturnValue, Error>>, propagateCancel?: boolean): Future<Result<ReturnValue, Error>>;
    flatMapError<Ok, Error, ReturnValue>(this: FutureClass<Result<Ok, Error>>, func: (value: Error) => Future<Result<Ok, ReturnValue>>, propagateCancel?: boolean): Future<Result<Ok, ReturnValue>>;
    toPromise(): Promise<Value>;
    resultToPromise<Ok, Error>(this: FutureClass<Result<Ok, Error>>): Promise<Ok>;
}
declare type Unwrap<Value extends Future<any>> = Value extends Future<infer T> ? T : unknown;
declare function all<Futures extends readonly Future<any>[] | []>(futures: Futures, propagateCancel?: boolean): Future<{
    -readonly [P in keyof Futures]: Futures[P] extends Future<any> ? Unwrap<Futures[P]> : never;
}>;
export declare const Future: {
    make: <Value>(init: (resolver: (value: Value) => void) => (() => void) | void) => Future<Value>;
    value: <Value_1>(value: Value_1) => Future<Value_1>;
    fromPromise<Value_2>(promise: Promise<Value_2>): Future<Result<Value_2, unknown>>;
    all: typeof all;
};
export {};
