import { Option } from "./Option";
export declare type AsyncData<Value> = AsyncDataClass<Value> & ({
    tag: "NotAsked";
    value: undefined;
} | {
    tag: "Loading";
    value: undefined;
} | {
    tag: "Done";
    value: Value;
});
declare class AsyncDataClass<Value> {
    tag: "NotAsked" | "Loading" | "Done";
    value: Value | undefined;
    constructor();
    map<ReturnValue>(f: (value: Value) => ReturnValue): AsyncData<ReturnValue>;
    flatMap<ReturnValue>(f: (value: Value) => AsyncData<ReturnValue>): AsyncData<ReturnValue>;
    getWithDefault(defaultValue: Value): Value;
    match<ReturnValue>(config: {
        Done: (value: Value) => ReturnValue;
        Loading: () => ReturnValue;
        NotAsked: () => ReturnValue;
    }): ReturnValue;
    isDone(): this is AsyncDataClass<Value> & {
        tag: "Done";
        value: Value;
    };
    isLoading(): this is AsyncDataClass<Value> & {
        tag: "Loading";
        value: undefined;
    };
    isNotAsked(): this is AsyncDataClass<Value> & {
        tag: "NotAsked";
        value: undefined;
    };
    toOption(): Option<Value>;
}
export declare const AsyncData: {
    Done: <Value>(value: Value) => AsyncData<Value>;
    Loading: <Value_1>() => AsyncData<Value_1>;
    NotAsked: <Value_2>() => AsyncData<Value_2>;
    equals: <Value_3>(a: AsyncData<Value_3>, b: AsyncData<Value_3>, equals: (a: Value_3, b: Value_3) => boolean) => boolean;
    pattern: {
        Done: <T>(x: T) => {
            readonly tag: "Done";
            readonly value: T;
        };
        NotAsked: {
            readonly tag: "NotAsked";
        };
        Loading: {
            readonly tag: "Loading";
        };
    };
};
export {};
