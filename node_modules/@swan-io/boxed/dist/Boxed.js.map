{"version":3,"file":"Boxed.js","sources":["../src/Option.ts","../src/Array.ts","../src/AsyncData.ts","../src/Result.ts","../src/Future.ts","../src/Deferred.ts","../src/Dict.ts","../src/Lazy.ts","../src/Serializer.ts"],"sourcesContent":["export type Option<Value> = OptionClass<Value> &\n  ({ tag: \"Some\"; value: Value } | { tag: \"None\"; value: undefined });\n\nclass OptionClass<Value> {\n  tag: \"Some\" | \"None\";\n  value: Value | undefined;\n  constructor() {\n    this.tag = \"None\";\n    this.value = undefined;\n  }\n  map<ReturnValue>(f: (value: Value) => ReturnValue): Option<ReturnValue> {\n    if (this.tag === \"Some\") {\n      return Option.Some(f(this.value as Value));\n    } else {\n      return this as unknown as Option<ReturnValue>;\n    }\n  }\n  flatMap<ReturnValue>(\n    f: (value: Value) => Option<ReturnValue>,\n  ): Option<ReturnValue> {\n    if (this.tag === \"Some\") {\n      return f(this.value as Value);\n    } else {\n      return this as unknown as Option<ReturnValue>;\n    }\n  }\n  getWithDefault(defaultValue: Value): Value {\n    if (this.tag === \"Some\") {\n      return this.value as Value;\n    } else {\n      return defaultValue;\n    }\n  }\n  match<ReturnValue>(config: {\n    Some: (value: Value) => ReturnValue;\n    None: () => ReturnValue;\n  }): ReturnValue {\n    if (this.tag === \"Some\") {\n      return config.Some(this.value as Value);\n    } else {\n      return config.None();\n    }\n  }\n  toUndefined() {\n    if (this.tag === \"None\") {\n      return undefined;\n    } else {\n      return this.value as Value;\n    }\n  }\n  toNull() {\n    if (this.tag === \"None\") {\n      return null;\n    } else {\n      return this.value as Value;\n    }\n  }\n  isSome(): this is OptionClass<Value> & { tag: \"Some\"; value: Value } {\n    return this.tag === \"Some\";\n  }\n  isNone(): this is OptionClass<Value> & { tag: \"None\"; value: undefined } {\n    return this.tag === \"None\";\n  }\n}\n\n// @ts-expect-error\nOptionClass.prototype.__boxed_type__ = \"Option\";\n\nconst proto = Object.create(\n  null,\n  Object.getOwnPropertyDescriptors(OptionClass.prototype),\n);\n\nconst NONE = (() => {\n  const none = Object.create(proto);\n  none.tag = \"None\";\n  none.value = undefined;\n  return none;\n})();\n\nexport const Option = {\n  Some: <Value>(value: Value): Option<Value> => {\n    const option = Object.create(proto) as Option<Value>;\n    option.tag = \"Some\";\n    option.value = value;\n    return option;\n  },\n  None: <Value>(): Option<Value> => {\n    return NONE as Option<Value>;\n  },\n  fromNullable: <NullableValue>(nullable: NullableValue) => {\n    if (nullable == null) {\n      return Option.None<NonNullable<NullableValue>>();\n    } else {\n      return Option.Some<NonNullable<NullableValue>>(\n        nullable as NonNullable<NullableValue>,\n      );\n    }\n  },\n  fromNull: <NullableValue>(nullable: NullableValue) => {\n    if (nullable === null) {\n      return Option.None<Exclude<NullableValue, null>>();\n    } else {\n      return Option.Some<Exclude<NullableValue, null>>(\n        nullable as Exclude<NullableValue, null>,\n      );\n    }\n  },\n  fromUndefined: <NullableValue>(nullable: NullableValue) => {\n    if (nullable === undefined) {\n      return Option.None<Exclude<NullableValue, undefined>>();\n    } else {\n      return Option.Some<Exclude<NullableValue, undefined>>(\n        nullable as Exclude<NullableValue, undefined>,\n      );\n    }\n  },\n  equals: <Value>(\n    a: Option<Value>,\n    b: Option<Value>,\n    equals: (a: Value, b: Value) => boolean,\n  ) => {\n    if (a.tag === \"Some\" && b.tag === \"Some\") {\n      return equals(a.value, b.value);\n    }\n    return a.tag === b.tag;\n  },\n  pattern: {\n    Some: <T>(x: T) => ({ tag: \"Some\", value: x } as const),\n    None: { tag: \"None\" } as const,\n  },\n};\n","import { Option } from \"./Option\";\n\nexport const from = Array.from;\n\nexport const of = Array.of;\n\nexport const isArray = Array.isArray;\n\nexport const keepMap = <A, B>(\n  array: Array<A>,\n  func: (item: A) => NonNullable<B> | undefined | null,\n): Array<NonNullable<B>> => {\n  const result: Array<NonNullable<B>> = [];\n  array.forEach((item) => {\n    const mapped = func(item);\n    if (mapped != null) {\n      result.push(mapped);\n    }\n  });\n  return result;\n};\n\nexport const getBy = <A>(\n  array: Array<A>,\n  func: (item: A) => boolean,\n): Option<A> => {\n  let index = -1;\n  while (++index < array.length) {\n    const item = array[index] as A;\n    if (func(item)) {\n      return Option.Some(item);\n    }\n  }\n  return Option.None();\n};\n\nexport const getIndexBy = <A>(\n  array: Array<A>,\n  func: (item: A) => boolean,\n): Option<number> => {\n  let index = -1;\n  while (++index < array.length) {\n    const item = array[index] as A;\n    if (func(item)) {\n      return Option.Some(index);\n    }\n  }\n  return Option.None();\n};\n\nconst defaultCompare = <A>(a: A, b: A) => {\n  if (a === b) {\n    return 0;\n  }\n  return a > b ? 1 : -1;\n};\n\nexport const binarySearchBy = <A>(\n  sortedArray: Array<A>,\n  key: A,\n  compare = defaultCompare,\n) => {\n  if (sortedArray.length === 0) {\n    return -1;\n  }\n  let low = 0;\n  let high = sortedArray.length - 1;\n  while (true) {\n    let mid = (low + (high - low) / 2) | 0;\n    if (mid === low || mid === high) {\n      return high;\n    }\n    let midItem = sortedArray[mid] as A;\n    let diff = compare(key, midItem);\n    if (diff === 0) {\n      return mid;\n    }\n    if (diff > 0) {\n      low = mid;\n      continue;\n    }\n    if (diff < 0) {\n      high = mid;\n      continue;\n    }\n  }\n};\n","import { Option } from \"./Option\";\n\nexport type AsyncData<Value> = AsyncDataClass<Value> &\n  (\n    | { tag: \"NotAsked\"; value: undefined }\n    | { tag: \"Loading\"; value: undefined }\n    | { tag: \"Done\"; value: Value }\n  );\n\nclass AsyncDataClass<Value> {\n  tag: \"NotAsked\" | \"Loading\" | \"Done\";\n  value: Value | undefined;\n  constructor() {\n    this.tag = \"NotAsked\";\n    this.value = undefined;\n  }\n  map<ReturnValue>(f: (value: Value) => ReturnValue): AsyncData<ReturnValue> {\n    if (this.tag === \"Done\") {\n      return AsyncData.Done(f(this.value as Value));\n    } else {\n      return this as unknown as AsyncData<ReturnValue>;\n    }\n  }\n  flatMap<ReturnValue>(\n    f: (value: Value) => AsyncData<ReturnValue>,\n  ): AsyncData<ReturnValue> {\n    if (this.tag === \"Done\") {\n      return f(this.value as Value);\n    } else {\n      return this as unknown as AsyncData<ReturnValue>;\n    }\n  }\n  getWithDefault(defaultValue: Value): Value {\n    if (this.tag === \"Done\") {\n      return this.value as Value;\n    } else {\n      return defaultValue;\n    }\n  }\n  match<ReturnValue>(config: {\n    Done: (value: Value) => ReturnValue;\n    Loading: () => ReturnValue;\n    NotAsked: () => ReturnValue;\n  }): ReturnValue {\n    if (this.tag === \"Done\") {\n      return config.Done(this.value as Value);\n    } else {\n      if (this.tag === \"Loading\") {\n        return config.Loading();\n      } else {\n        return config.NotAsked();\n      }\n    }\n  }\n  isDone(): this is AsyncDataClass<Value> & { tag: \"Done\"; value: Value } {\n    return this.tag === \"Done\";\n  }\n  isLoading(): this is AsyncDataClass<Value> & {\n    tag: \"Loading\";\n    value: undefined;\n  } {\n    return this.tag === \"Loading\";\n  }\n  isNotAsked(): this is AsyncDataClass<Value> & {\n    tag: \"NotAsked\";\n    value: undefined;\n  } {\n    return this.tag === \"NotAsked\";\n  }\n  toOption(): Option<Value> {\n    if (this.tag === \"Done\") {\n      return Option.Some(this.value) as Option<Value>;\n    } else {\n      return Option.None() as Option<Value>;\n    }\n  }\n}\n\n// @ts-expect-error\nAsyncDataClass.prototype.__boxed_type__ = \"AsyncData\";\n\nconst proto = Object.create(\n  null,\n  Object.getOwnPropertyDescriptors(AsyncDataClass.prototype),\n);\n\nconst LOADING = (() => {\n  const asyncData = Object.create(proto);\n  asyncData.tag = \"Loading\";\n  asyncData.value = undefined;\n  return asyncData;\n})();\n\nconst NOT_ASKED = (() => {\n  const asyncData = Object.create(proto);\n  asyncData.tag = \"NotAsked\";\n  asyncData.value = undefined;\n  return asyncData;\n})();\n\nexport const AsyncData = {\n  Done: <Value>(value: Value): AsyncData<Value> => {\n    const asyncData = Object.create(proto) as AsyncData<Value>;\n    asyncData.tag = \"Done\";\n    asyncData.value = value;\n    return asyncData;\n  },\n  Loading: <Value>(): AsyncData<Value> => {\n    return LOADING as AsyncData<Value>;\n  },\n  NotAsked: <Value>(): AsyncData<Value> => {\n    return NOT_ASKED as AsyncData<Value>;\n  },\n  equals: <Value>(\n    a: AsyncData<Value>,\n    b: AsyncData<Value>,\n    equals: (a: Value, b: Value) => boolean,\n  ) => {\n    if (a.tag === \"Done\" && b.tag === \"Done\") {\n      return equals(a.value, b.value);\n    }\n    return a.tag === b.tag;\n  },\n  pattern: {\n    Done: <T>(x: T) => ({ tag: \"Done\", value: x } as const),\n    NotAsked: { tag: \"NotAsked\" } as const,\n    Loading: { tag: \"Loading\" } as const,\n  },\n};\n","import { Option } from \"./Option\";\n\nexport type Result<Ok, Error> = ResultClass<Ok, Error> &\n  ({ tag: \"Ok\"; value: Ok } | { tag: \"Error\"; value: Error });\n\nclass ResultClass<Ok, Error> {\n  tag: \"Ok\" | \"Error\";\n  value: Ok | Error;\n  constructor() {\n    this.tag = undefined as unknown as \"Ok\" | \"Error\";\n    this.value = undefined as unknown as Ok | Error;\n  }\n  map<ReturnValue>(f: (value: Ok) => ReturnValue): Result<ReturnValue, Error> {\n    if (this.tag === \"Ok\") {\n      return Result.Ok(f(this.value as Ok));\n    } else {\n      return this as unknown as Result<ReturnValue, Error>;\n    }\n  }\n  flatMap<ReturnValue>(\n    f: (value: Ok) => Result<ReturnValue, Error>,\n  ): Result<ReturnValue, Error> {\n    if (this.tag === \"Ok\") {\n      return f(this.value as Ok);\n    } else {\n      return this as unknown as Result<ReturnValue, Error>;\n    }\n  }\n  getWithDefault(defaultValue: Ok): Ok {\n    if (this.tag === \"Ok\") {\n      return this.value as Ok;\n    } else {\n      return defaultValue;\n    }\n  }\n  match<ReturnValue>(config: {\n    Ok: (value: Ok) => ReturnValue;\n    Error: (error: Error) => ReturnValue;\n  }): ReturnValue {\n    if (this.tag === \"Ok\") {\n      return config.Ok(this.value as Ok);\n    } else {\n      return config.Error(this.value as Error);\n    }\n  }\n  isOk(): this is Result<Ok, Error> & { tag: \"Ok\"; value: Ok } {\n    return this.tag === \"Ok\";\n  }\n  isError(): this is Result<Ok, Error> & { tag: \"Error\"; value: Error } {\n    return this.tag === \"Error\";\n  }\n  toOption(): Option<Ok> {\n    if (this.tag === \"Ok\") {\n      return Option.Some(this.value) as Option<Ok>;\n    } else {\n      return Option.None() as Option<Ok>;\n    }\n  }\n}\n\n// @ts-expect-error\nResultClass.prototype.__boxed_type__ = \"Result\";\n\nconst proto = Object.create(\n  null,\n  Object.getOwnPropertyDescriptors(ResultClass.prototype),\n);\n\nexport const Result = {\n  Ok: <Ok, Error>(ok: Ok): Result<Ok, Error> => {\n    const result = Object.create(proto) as Result<Ok, Error>;\n    result.tag = \"Ok\";\n    result.value = ok;\n    return result;\n  },\n  Error: <Ok, Error>(error: Error): Result<Ok, Error> => {\n    const result = Object.create(proto) as Result<Ok, Error>;\n    result.tag = \"Error\";\n    result.value = error;\n    return result;\n  },\n  fromExecution<ReturnValue, Error = unknown>(\n    func: () => ReturnValue,\n  ): Result<ReturnValue, Error> {\n    try {\n      return Result.Ok(func());\n    } catch (err) {\n      return Result.Error(err) as Result<ReturnValue, Error>;\n    }\n  },\n  async fromPromise<ReturnValue, Error = unknown>(\n    promise: Promise<ReturnValue>,\n  ): Promise<Result<ReturnValue, Error>> {\n    try {\n      const value = await promise;\n      return Result.Ok<ReturnValue, Error>(value);\n    } catch (err) {\n      return Result.Error<ReturnValue, Error>(err as Error);\n    }\n  },\n  equals: <Value, Error>(\n    a: Result<Value, Error>,\n    b: Result<Value, Error>,\n    equals: (a: Value, b: Value) => boolean,\n  ) => {\n    if (a.tag !== b.tag) {\n      return false;\n    }\n    if (a.tag === \"Error\" && b.tag === \"Error\") {\n      return true;\n    }\n    return equals(a.value as unknown as Value, b.value as unknown as Value);\n  },\n  pattern: {\n    Ok: <T>(x: T) => ({ tag: \"Ok\", value: x } as const),\n    Error: <T>(x: T) => ({ tag: \"Error\", value: x } as const),\n  },\n};\n","import { Result } from \"./Result\";\n\ntype PendingPayload<Value> = {\n  resolveCallbacks?: Array<(value: Value) => void>;\n  cancelCallbacks?: Array<() => void>;\n  cancel?: void | (() => void);\n};\n\nexport type Future<Value> = FutureClass<Value> &\n  (\n    | { tag: \"Pending\"; pending: PendingPayload<Value> }\n    | { tag: \"Cancelled\" }\n    | { tag: \"Resolved\"; value: Value }\n  );\n\nfunction FutureInit<Value>(\n  this: FutureClass<Value>,\n  init: (resolver: (value: Value) => void) => (() => void) | void,\n) {\n  const resolver = (value: Value) => {\n    if (this.tag === \"Pending\") {\n      const pending = this.pending as PendingPayload<Value>;\n      const resolveCallbacks = pending.resolveCallbacks;\n      resolveCallbacks?.forEach((func) => func(value));\n      this.tag = \"Resolved\";\n      this.value = value;\n      this.pending = undefined;\n    }\n  };\n  const pendingPayload: PendingPayload<Value> = {};\n  this.tag = \"Pending\";\n  this.pending = pendingPayload;\n  pendingPayload.cancel = init(resolver);\n}\n\nclass FutureClass<Value> {\n  tag: \"Pending\" | \"Cancelled\" | \"Resolved\";\n  value?: Value;\n  pending?: PendingPayload<Value>;\n  constructor(\n    _init: (resolver: (value: Value) => void) => (() => void) | void,\n  ) {\n    const pendingPayload: PendingPayload<Value> = {};\n    this.tag = \"Pending\";\n    this.pending = pendingPayload;\n  }\n  isPending(): this is FutureClass<Value> & {\n    tag: \"Pending\";\n    value: PendingPayload<Value>;\n  } {\n    return this.tag === \"Pending\";\n  }\n  isCancelled(): this is FutureClass<Value> & {\n    tag: \"Cancelled\";\n    value: undefined;\n  } {\n    return this.tag === \"Cancelled\";\n  }\n  isResolved(): this is FutureClass<Value> & {\n    tag: \"Resolved\";\n    value: Value;\n  } {\n    return this.tag === \"Resolved\";\n  }\n  get(func: (value: Value) => void) {\n    if (this.isPending()) {\n      const pending = this.pending as PendingPayload<Value>;\n      pending.resolveCallbacks = pending.resolveCallbacks ?? [];\n      pending.resolveCallbacks.push(func);\n    }\n    if (this.isResolved()) {\n      func(this.value);\n    }\n  }\n  onCancel(func: () => void) {\n    if (this.isPending()) {\n      const pending = this.pending as PendingPayload<Value>;\n      pending.cancelCallbacks = pending.cancelCallbacks ?? [];\n      pending.cancelCallbacks.push(func);\n    }\n    if (this.isCancelled()) {\n      func();\n    }\n  }\n  cancel() {\n    if (this.tag === \"Pending\") {\n      this.tag = \"Cancelled\";\n      this.value = undefined;\n      const pending = this.pending as PendingPayload<Value>;\n      const cancelCallbacks = pending.cancelCallbacks;\n      pending.cancel?.();\n      cancelCallbacks?.forEach((func) => func());\n      this.pending = undefined;\n    }\n  }\n  map<ReturnValue>(\n    func: (value: Value) => ReturnValue,\n    propagateCancel = false,\n  ): Future<ReturnValue> {\n    const future = Future.make<ReturnValue>((resolve) => {\n      this.get((value) => {\n        resolve(func(value));\n      });\n      if (propagateCancel) {\n        return () => {\n          this.cancel();\n        };\n      }\n    });\n    this.onCancel(() => {\n      future.cancel();\n    });\n    return future as Future<ReturnValue>;\n  }\n  then(func: (value: Value) => void) {\n    this.get(func);\n    return this;\n  }\n  flatMap<ReturnValue>(\n    func: (value: Value) => Future<ReturnValue>,\n    propagateCancel = false,\n  ): Future<ReturnValue> {\n    const future = Future.make<ReturnValue>((resolve) => {\n      this.get((value) => {\n        const returnedFuture = func(value);\n        returnedFuture.get(resolve);\n        returnedFuture.onCancel(() => future.cancel());\n      });\n      if (propagateCancel) {\n        return () => {\n          this.cancel();\n        };\n      }\n    });\n    this.onCancel(() => {\n      future.cancel();\n    });\n    return future as Future<ReturnValue>;\n  }\n  tap(func: (value: Value) => unknown): Future<Value> {\n    this.get(func);\n    return this as Future<Value>;\n  }\n  tapOk<Ok, Error>(\n    this: FutureClass<Result<Ok, Error>>,\n    func: (value: Ok) => unknown,\n  ): Future<Result<Ok, Error>> {\n    this.get((value) => {\n      value.match({\n        Ok: (value) => func(value),\n        Error: () => {},\n      });\n    });\n    return this as Future<Result<Ok, Error>>;\n  }\n  tapError<Ok, Error>(\n    this: FutureClass<Result<Ok, Error>>,\n    func: (value: Error) => unknown,\n  ): Future<Result<Ok, Error>> {\n    this.get((value) => {\n      value.match({\n        Ok: () => {},\n        Error: (error) => func(error),\n      });\n    });\n    return this as Future<Result<Ok, Error>>;\n  }\n  mapResult<Ok, Error, ReturnValue>(\n    this: FutureClass<Result<Ok, Error>>,\n    func: (value: Ok) => Result<ReturnValue, Error>,\n    propagateCancel = false,\n  ): Future<Result<ReturnValue, Error>> {\n    return this.map((value) => {\n      return value.match({\n        Ok: (value) => func(value),\n        Error: () => value as unknown as Result<ReturnValue, Error>,\n      });\n    }, propagateCancel);\n  }\n  mapOk<Ok, Error, ReturnValue>(\n    this: FutureClass<Result<Ok, Error>>,\n    func: (value: Ok) => ReturnValue,\n    propagateCancel = false,\n  ): Future<Result<ReturnValue, Error>> {\n    return this.map((value) => {\n      return value.match({\n        Ok: (value) => Result.Ok(func(value)),\n        Error: () => value as unknown as Result<ReturnValue, Error>,\n      });\n    }, propagateCancel);\n  }\n  mapError<Ok, Error, ReturnValue>(\n    this: FutureClass<Result<Ok, Error>>,\n    func: (value: Error) => ReturnValue,\n    propagateCancel = false,\n  ): Future<Result<Ok, ReturnValue>> {\n    return this.map((value) => {\n      return value.match({\n        Ok: () => value as unknown as Result<Ok, ReturnValue>,\n        Error: (error) => Result.Error(func(error)),\n      });\n    }, propagateCancel);\n  }\n  flatMapOk<Ok, Error, ReturnValue>(\n    this: FutureClass<Result<Ok, Error>>,\n    func: (value: Ok) => Future<Result<ReturnValue, Error>>,\n    propagateCancel = false,\n  ): Future<Result<ReturnValue, Error>> {\n    return this.flatMap((value) => {\n      return value.match({\n        Ok: (value) => func(value),\n        Error: () =>\n          Future.value(value as unknown as Result<ReturnValue, Error>),\n      });\n    }, propagateCancel);\n  }\n  flatMapError<Ok, Error, ReturnValue>(\n    this: FutureClass<Result<Ok, Error>>,\n    func: (value: Error) => Future<Result<Ok, ReturnValue>>,\n    propagateCancel = false,\n  ): Future<Result<Ok, ReturnValue>> {\n    return this.flatMap((value) => {\n      return value.match({\n        Ok: () => Future.value(value as unknown as Result<Ok, ReturnValue>),\n        Error: (error) => func(error),\n      });\n    }, propagateCancel);\n  }\n  toPromise(): Promise<Value> {\n    return new Promise((resolve) => {\n      this.get(resolve);\n    });\n  }\n  resultToPromise<Ok, Error>(\n    this: FutureClass<Result<Ok, Error>>,\n  ): Promise<Ok> {\n    return new Promise((resolve, reject) => {\n      this.get((value) => {\n        value.match({\n          Ok: resolve,\n          Error: reject,\n        });\n      });\n    });\n  }\n}\n\ntype Unwrap<Value extends Future<any>> = Value extends Future<infer T>\n  ? T\n  : unknown;\n\nfunction all<Futures extends readonly Future<any>[] | []>(\n  futures: Futures,\n  propagateCancel = false,\n): Future<{\n  -readonly [P in keyof Futures]: Futures[P] extends Future<any>\n    ? Unwrap<Futures[P]>\n    : never;\n}> {\n  const length = futures.length;\n  let acc = Future.value<Array<unknown>>([]);\n  let index = 0;\n  while (true) {\n    if (index >= length) {\n      return acc as unknown as Future<{\n        -readonly [P in keyof Futures]: Futures[P] extends Future<any>\n          ? Unwrap<Futures[P]>\n          : never;\n      }>;\n    }\n    const item = futures[index] as Future<unknown>;\n    let accCache = acc;\n    acc = item.flatMap((value) => {\n      return accCache.map((array) => {\n        array.push(value);\n        return array;\n      }, propagateCancel);\n    }, propagateCancel);\n    index++;\n  }\n}\n\nconst proto = Object.create(\n  null,\n  Object.getOwnPropertyDescriptors(FutureClass.prototype),\n);\n\nexport const Future = {\n  make: <Value>(\n    init: (resolver: (value: Value) => void) => (() => void) | void,\n  ): Future<Value> => {\n    const future = Object.create(proto);\n    FutureInit.call(future, init);\n    return future as Future<Value>;\n  },\n  value: <Value>(value: Value): Future<Value> => {\n    const future = Object.create(proto);\n    FutureInit.call(future, (resolve) => resolve(value));\n    return future as Future<Value>;\n  },\n  fromPromise<Value>(promise: Promise<Value>): Future<Result<Value, unknown>> {\n    return Future.make((resolve) => {\n      promise.then(\n        (ok) => resolve(Result.Ok(ok)),\n        (reason) => resolve(Result.Error(reason)),\n      );\n    });\n  },\n  all,\n};\n","import { Future } from \"./Future\";\n\nexport const Deferred = {\n  make<Value>() {\n    let resolver: ((value: Value) => void) | undefined = undefined;\n    const future = Future.make((resolve) => {\n      resolver = resolve;\n    });\n    return [future, resolver as unknown as (value: Value) => void] as const;\n  },\n};\n","export function entries<T>(value: T) {\n  return Object.entries(value) as NonNullable<\n    {\n      [K in keyof T]: K extends string ? [K, T[K]] : never;\n    }[keyof T]\n  >[];\n}\n\nexport function keys<T>(value: T) {\n  return Object.keys(value) as NonNullable<\n    {\n      [K in keyof T]: K extends string ? K : never;\n    }[keyof T]\n  >[];\n}\n\nexport function values<T>(value: T) {\n  return Object.values(value) as {\n    [K in keyof T]: K extends string ? T[K] : never;\n  }[keyof T][];\n}\n","type Ref<T> = { contents: T };\n\nconst NOT_COMPUTED = Symbol.for(\"NOT_COMPUTED\");\n\nexport const Lazy = <Value>(func: () => Value): { value: Value } => {\n  const value: Ref<Value | typeof NOT_COMPUTED> = { contents: NOT_COMPUTED };\n  return {\n    get value() {\n      if (value.contents === NOT_COMPUTED) {\n        value.contents = func();\n      }\n      return value.contents;\n    },\n  };\n};\n","import { AsyncData } from \"./AsyncData\";\nimport { Option } from \"./Option\";\nimport { Result } from \"./Result\";\n\nexport const encode = (value: any, indent?: number | undefined) => {\n  return JSON.stringify(\n    value,\n    function (key, value) {\n      if (value == null) {\n        return;\n      }\n      if (value.__boxed_type__ === \"Option\") {\n        return {\n          __boxed_type__: \"Option\",\n          tag: value.tag,\n          value: value.value,\n        };\n      }\n      if (value.__boxed_type__ === \"Result\") {\n        return {\n          __boxed_type__: \"Result\",\n          tag: value.tag,\n          value: value.value,\n        };\n      }\n      if (value.__boxed_type__ === \"AsyncData\") {\n        return {\n          __boxed_type__: \"AsyncData\",\n          tag: value.tag,\n          value: value.value,\n        };\n      }\n      return value;\n    },\n    indent,\n  );\n};\n\nexport const decode = (value: string) => {\n  return JSON.parse(value, function (key, value) {\n    if (value == null) {\n      return value;\n    }\n    if (value.__boxed_type__ === \"Option\") {\n      return value.tag === \"Some\" ? Option.Some(value.value) : Option.None();\n    }\n    if (value.__boxed_type__ === \"Result\") {\n      return value.tag === \"Ok\"\n        ? Result.Ok(value.value)\n        : Result.Error(value.value);\n    }\n    if (value.__boxed_type__ === \"AsyncData\") {\n      return value.tag === \"NotAsked\"\n        ? AsyncData.NotAsked()\n        : value.tag === \"Loading\"\n        ? AsyncData.Loading()\n        : AsyncData.Done(value.value);\n    }\n    return value;\n  });\n};\n"],"names":["OptionClass","tag","value","this","undefined","map","f","Option","Some","flatMap","getWithDefault","defaultValue","match","config","None","toUndefined","toNull","isSome","isNone","prototype","__boxed_type__","none","proto","Object","create","getOwnPropertyDescriptors","NONE","option","fromNullable","nullable","fromNull","fromUndefined","equals","a","b","pattern","x","defaultCompare","Array","from","of","isArray","array","func","result","forEach","item","mapped","push","index","length","sortedArray","key","compare","low","high","mid","diff","AsyncDataClass","AsyncData","Done","Loading","NotAsked","isDone","isLoading","isNotAsked","toOption","asyncData","LOADING","NOT_ASKED","ResultClass","Result","Ok","Error","isOk","isError","ok","error","fromExecution","err","fromPromise","promise","Promise","resolve","_catch","FutureInit","init","_this","pendingPayload","pending","cancel","resolveCallbacks","_init","isPending","isCancelled","isResolved","get","_pending$resolveCallb","onCancel","_pending$cancelCallba","cancelCallbacks","propagateCancel","_this2","future","Future","make","then","_this3","returnedFuture","tap","tapOk","tapError","mapResult","mapOk","mapError","flatMapOk","flatMapError","toPromise","_this4","resultToPromise","_this5","reject","FutureClass","call","reason","all","futures","acc","v","accCache","_ret","_loop","Deferred","resolver","entries","keys","values","NOT_COMPUTED","Symbol","contents","indent","JSON","stringify","parse"],"mappings":"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"}