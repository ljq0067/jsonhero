import { Option } from "./Option";
export declare type Result<Ok, Error> = ResultClass<Ok, Error> & ({
    tag: "Ok";
    value: Ok;
} | {
    tag: "Error";
    value: Error;
});
declare class ResultClass<Ok, Error> {
    tag: "Ok" | "Error";
    value: Ok | Error;
    constructor();
    map<ReturnValue>(f: (value: Ok) => ReturnValue): Result<ReturnValue, Error>;
    flatMap<ReturnValue>(f: (value: Ok) => Result<ReturnValue, Error>): Result<ReturnValue, Error>;
    getWithDefault(defaultValue: Ok): Ok;
    match<ReturnValue>(config: {
        Ok: (value: Ok) => ReturnValue;
        Error: (error: Error) => ReturnValue;
    }): ReturnValue;
    isOk(): this is Result<Ok, Error> & {
        tag: "Ok";
        value: Ok;
    };
    isError(): this is Result<Ok, Error> & {
        tag: "Error";
        value: Error;
    };
    toOption(): Option<Ok>;
}
export declare const Result: {
    Ok: <Ok, Error_1>(ok: Ok) => Result<Ok, Error_1>;
    Error: <Ok_1, Error_2>(error: Error_2) => Result<Ok_1, Error_2>;
    fromExecution<ReturnValue, Error_3 = unknown>(func: () => ReturnValue): Result<ReturnValue, Error_3>;
    fromPromise<ReturnValue_1, Error_4 = unknown>(promise: Promise<ReturnValue_1>): Promise<Result<ReturnValue_1, Error_4>>;
    equals: <Value, Error_5>(a: Result<Value, Error_5>, b: Result<Value, Error_5>, equals: (a: Value, b: Value) => boolean) => boolean;
    pattern: {
        Ok: <T>(x: T) => {
            readonly tag: "Ok";
            readonly value: T;
        };
        Error: <T_1>(x: T_1) => {
            readonly tag: "Error";
            readonly value: T_1;
        };
    };
};
export {};
