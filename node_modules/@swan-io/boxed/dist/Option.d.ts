export declare type Option<Value> = OptionClass<Value> & ({
    tag: "Some";
    value: Value;
} | {
    tag: "None";
    value: undefined;
});
declare class OptionClass<Value> {
    tag: "Some" | "None";
    value: Value | undefined;
    constructor();
    map<ReturnValue>(f: (value: Value) => ReturnValue): Option<ReturnValue>;
    flatMap<ReturnValue>(f: (value: Value) => Option<ReturnValue>): Option<ReturnValue>;
    getWithDefault(defaultValue: Value): Value;
    match<ReturnValue>(config: {
        Some: (value: Value) => ReturnValue;
        None: () => ReturnValue;
    }): ReturnValue;
    toUndefined(): Value | undefined;
    toNull(): Value | null;
    isSome(): this is OptionClass<Value> & {
        tag: "Some";
        value: Value;
    };
    isNone(): this is OptionClass<Value> & {
        tag: "None";
        value: undefined;
    };
}
export declare const Option: {
    Some: <Value>(value: Value) => Option<Value>;
    None: <Value_1>() => Option<Value_1>;
    fromNullable: <NullableValue>(nullable: NullableValue) => Option<NonNullable<NullableValue>>;
    fromNull: <NullableValue_1>(nullable: NullableValue_1) => Option<Exclude<NullableValue_1, null>>;
    fromUndefined: <NullableValue_2>(nullable: NullableValue_2) => Option<Exclude<NullableValue_2, undefined>>;
    equals: <Value_2>(a: Option<Value_2>, b: Option<Value_2>, equals: (a: Value_2, b: Value_2) => boolean) => boolean;
    pattern: {
        Some: <T>(x: T) => {
            readonly tag: "Some";
            readonly value: T;
        };
        None: {
            readonly tag: "None";
        };
    };
};
export {};
